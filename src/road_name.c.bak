#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <pthread.h> 

#include "road_name.h"

//static int ncount;    // 쓰레드간 공유되는 자원 
//static pthread_mutex_t  mutex = PTHREAD_MUTEX_INITIALIZER; // 쓰레드 초기화 

static void download(char *path, char *downurl, char *downpath, char *outfilename);

typedef enum {
    SOURCE_TYPE_NONE,
    SOURCE_TYPE_DOWNLOAD,
    SOURCE_TYPE_UNZIP,
    SOURCE_TYPE_SQLITE,
    SOURCE_TYPE_ORACLE,
    SOURCE_TYPE_TEST
} source_type_t;
 
void getIniValue(char *section, char *key, char **output_buf_ptr)
{
	char ret_buf[1024] = {0x00, }; 
	char *value;
	
#ifdef WITH_CONV
	size_t in_size, out_size;
#endif	
	
	value = ret_buf;
	
	read_ini(section, key, NULL, &value);
	printf("in [%s][%s]=--> [%s] \n", section, key, value);
	
	
#ifdef WITH_CONV
	char tmpbuf[1024];	
	memset(tmpbuf, 0x00, sizeof(tmpbuf));
	
	in_size = strlen(value) +1;
	out_size = sizeof(tmpbuf);
	
	convStr( tmpbuf, &out_size, ret_buf, in_size, "EUC-KR", "UTF-8");
	memcpy(*output_buf_ptr, tmpbuf, strlen(tmpbuf) + 1);
	
#else
	memcpy(*output_buf_ptr, value, strlen(value)+1);
#endif

	printf("---> out[%s] \n", *output_buf_ptr);	
}

void unzipRoadData(char *downpath, char *path, char* outfilename)
{
	char buff[1024];
	char tmpbuf[1024];	
	char ret_buf[1024];	
	
	size_t in_size, out_size;
	
	memset(tmpbuf, 0x00, sizeof(tmpbuf));
	memset(ret_buf, 0x00, sizeof(ret_buf));
	
	create_dir(downpath);
	
	rename(outfilename, path);

	if (chdir(downpath) == 0) {
	    printf("Directory changed successfully.\n");
	}else{
	    printf("Could not change directory.\n");
	}
	
	in_size = strlen(outfilename) +1;
	out_size = sizeof(tmpbuf);
	
	convStr( tmpbuf, &out_size, outfilename, in_size, "UTF-8", "EUC-KR");
	
	getcwd( buff, 1024);                   // 작업 디렉토리 구하기
	printf( "=: Current Working dir[%s]\n", buff);
	
	printf( "=: Current file[%s][%s]\n", tmpbuf, outfilename);
	smpl_unzip(tmpbuf);
}

void parseScheme(char *filename)
{
	char *retText = new char[FILENAME_MAX];
	
	//retText = (char*)malloc(sizeof(char)*FILENAME_MAX);
	
	//char **xmlText = &retText;
	
	pre_load_scheme(filename, "tb_addr_map_tmp2", "create", &retText);
	
	//printf("---> out[%s] \n", retText);	
	
	//if(retText) free(retText);
	delete retText;
	retText = NULL;
}

static void
usage(const char *progname, const char *reason)
{
    unsigned int i;
    FILE *out;
    
    if (reason == NULL)
		out = stdout;
    else
		out = stderr;
	
    fprintf(out, "usage: %s [-cegHhmnrst] archive command1 [args] [command2 [args] ...]\n", progname);
    
    if (reason != NULL) {
		fprintf(out, "%s\n", reason);
		exit(1);
    }

    fprintf(out, "\nSupported options are:\n"
	    "\t-d\tdownload road name ascii text, which is zip file format from url specified in INI file\n"
	    "\t-u\tunzip zip file (must use with -d option)\n"
	    "\t-h\tdisplay this usage\n"
	    "\t-s\tcopy extracted road name data to sqlite database with scheme provided with xml file\n"
	    "\t-o\tfrom sqlite database to oracle database after verificantion of data\n"
	    "\t-t\ttest zip file, extract the data from that, make sqlite database and tranfer database to oracle database finally\n");
    
    exit(0);
}


int main(int argc, char *argv[])
{
	const char *archive;
	unsigned int i;
	int c, arg, err, flags;
	const char *prg;
	source_type_t source_type = SOURCE_TYPE_NONE;
	
	flags = 0;
	prg = argv[0];
	
	if (argc < 2)
	usage(prg, "too few arguments");
	
	while ((c=getopt(argc, argv, "duhso")) != -1) {
		switch (c) {
			case 'd':
			    flags |= ROAD_DOWNLOAD;
			    source_type = SOURCE_TYPE_DOWNLOAD;
			    break;
			case 'u':
			    flags |= ROAD_UNZIP;
			    source_type = SOURCE_TYPE_UNZIP;
			    break;
			case 'h':
			    usage(prg, NULL);
			    break;
			case 's':
			    flags |= ROAD_SQLITE;
			    source_type = SOURCE_TYPE_SQLITE;
			    break;
			case 'o':
			    flags |= ROAD_ORACLE;
			    source_type = SOURCE_TYPE_ORACLE;
			    break;
			case 't':
			    flags |= ROAD_TEST;
			    source_type = SOURCE_TYPE_TEST;
			    break;
			
			default:
			{
			    char reason[128];
			    snprintf(reason, sizeof(reason), "invalid option -%c", optopt);
			    usage(prg, reason);
			}
		}
	}
	
	arg = optind;
	
	archive = argv[arg++];
	
	if (flags == 0) flags = ROAD_DOWNLOAD;
	
	char durl[FILENAME_MAX] = {0x00, }; 
	char filename[FILENAME_MAX] = {0x00, }; 
	char dpath[FILENAME_MAX] = {0x00, }; 
	char path[FILENAME_MAX] = {0x00, }; 
	char sfile[FILENAME_MAX] = {0x00, };
	
	char *downpath;
	char *downurl;
	
	char *outfilename = filename;
	char *schmefile = sfile;
	char *section1 = SECTION1;
	char *section3 = SECTION3;
	
	if(!archive)
		load_ini(INI_FILE);
	else
		load_ini(archive);
	
	//pthread_mutex_lock(&mutex); // 잠금을 생성한다.
	
	if(source_type != SOURCE_TYPE_TEST)
	{
		downpath = dpath;
		downurl = durl;
		
		//outfilename = getIniValue(SECTION1, "OUT_FILE", 1);
		//getIniValue(SECTION1, "OUT_FILE", &outfilename);
		read_ini(section1, "OUT_FILE", NULL, &outfilename);
		printf("file =--> [%s][%d][%d] \n", outfilename, sizeof(outfilename), strlen(outfilename));
		
		//getIniValue(SECTION1, "DOWN_URL", &downurl); 
		read_ini(section1, "DOWN_URL", NULL, &downurl);
		printf("url =--> [%s][%d][%d] \n", downurl, sizeof(downurl), strlen(downurl));
		
		read_ini(SECTION1, "DOWN_PATH", NULL, &downpath);
		sprintf(path, "%s/%s", downpath, outfilename);
		
		read_ini(section3, "SCHEME", NULL, &schmefile);
		printf("SCHEME/%s \n", schmefile);
		
		
		switch (source_type) {
		    case SOURCE_TYPE_NONE:
		        download(path, downurl, downpath, outfilename);
		        break;
		
		    case SOURCE_TYPE_DOWNLOAD:
		        download(path, downurl, downpath, outfilename);
		        break;
		
		    case SOURCE_TYPE_UNZIP: {
		        unzipRoadData(downpath, path, outfilename);
		        break;
		    }
		     case SOURCE_TYPE_SQLITE:
		        break;
		
		    case SOURCE_TYPE_ORACLE:
		        break;
		
		    case SOURCE_TYPE_TEST: {
		        break;
		    }
		}
	} 
	else
	{
		/*char *url = "https://www.juso.go.kr/addrlink/addressBuildDev.do";*/
		strcpy( downurl, 
			"https://www.juso.go.kr/dn.do?reqType=ALLRDNM&fileName=201608전체주소(도로명코드)_전체분.zip&realFileName=201608ALLRDNM00.zip&regYmd=2016&ctprvnCd=00&gubun=RDNM&stdde=201608");
		strcpy(filename, "201608전체주소(도로명코드)_전체분.zip");
		
		printf("file =--> [%s][%d][%d] \n", outfilename, sizeof(outfilename), strlen(outfilename));
		printf("url =--> [%s][%d][%d] \n", downurl, sizeof(downurl), strlen(downurl));
	}

	
	printf("parsing ... done ...."); 
	
	unload_ini();
	
	
	return err;
}

void download(char *path, char *downurl, char *downpath, char *outfilename)
{
	if(!file_exists(path))
	{
		download_http(downurl, outfilename);
		
	}
	else
		printf("%s exists!!\n", path);
}

int main(int argc, char **argv)
{
	printf("parsing ... done ....");
#ifndef TEST_DOWNLOAD
	char durl[FILENAME_MAX] = {0x00, }; 
	char filename[FILENAME_MAX] = {0x00, }; 
	char dpath[FILENAME_MAX] = {0x00, }; 
	char path[FILENAME_MAX] = {0x00, }; 
	char sfile[FILENAME_MAX] = {0x00, };
	
	char *downpath = dpath;
	char *downurl = durl;
#else
	/*char *url = "https://www.juso.go.kr/addrlink/addressBuildDev.do";*/
	char downurl[FILENAME_MAX] = "https://www.juso.go.kr/dn.do?reqType=ALLRDNM&fileName=201608전체주소(도로명코드)_전체분.zip&realFileName=201608ALLRDNM00.zip&regYmd=2016&ctprvnCd=00&gubun=RDNM&stdde=201608";
	char filename[FILENAME_MAX] = "201608전체주소(도로명코드)_전체분.zip";
	
#endif

	char *outfilename = filename;
	char *schmefile = sfile;
	
	printf("parsing ... done ....");
	
	load_ini(INI_FILE);
	
	//pthread_mutex_lock(&mutex); // 잠금을 생성한다.
	
#ifndef TEST_DOWNLOAD
	char *section1 = SECTION1;
	char *section3 = SECTION3;
	//outfilename = getIniValue(SECTION1, "OUT_FILE", 1);
	//getIniValue(SECTION1, "OUT_FILE", &outfilename);
	read_ini(section1, "OUT_FILE", NULL, &outfilename);
	printf("file =--> [%s][%d][%d] \n", outfilename, sizeof(outfilename), strlen(outfilename));
	
	//getIniValue(SECTION1, "DOWN_URL", &downurl); 
	read_ini(section1, "DOWN_URL", NULL, &downurl);
	printf("url =--> [%s][%d][%d] \n", downurl, sizeof(downurl), strlen(downurl));
	
	read_ini(SECTION1, "DOWN_PATH", NULL, &downpath);
	sprintf(path, "%s/%s", downpath, outfilename);
	
	read_ini(section3, "SCHEME", NULL, &schmefile);
	printf("SCHEME/%s \n", schmefile);
	
#else
	printf("file =--> [%s][%d][%d] \n", outfilename, sizeof(outfilename), strlen(outfilename));
	printf("url =--> [%s][%d][%d] \n", downurl, sizeof(downurl), strlen(downurl));
	
#endif 
	
	unload_ini();
	
	//pthread_mutex_unlock(&mutex); // 잠금을 해제한다. 
	
	if(!file_exists(path))
	{
		download_http(downurl, outfilename);
		unzipRoadData(downpath, path, outfilename);
	}
	else
		printf("%s exists!!\n", path);
	
	printf("parsing %s \n", schmefile);
		
	parseScheme(schmefile);
	
	printf("parsing ... done ....");
	
	return 0;
}